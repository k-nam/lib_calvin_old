package db

import java.sql.{DriverManager, Connection};
import scala.collection.mutable.ArrayBuffer

abstract class DbManager extends Thread {
  val connection: Connection
  
  override def run(): Unit = {
    pushData()
  }
  
  def getPersonList(): Array[String] = {
    val stmt = connection.createStatement()
    val rs = stmt.executeQuery("SELECT id from Me2Person")
    var personArray = new ArrayBuffer[String]()
    while (rs.next()) {
      val id = rs.getString("id")
      personArray += id
    }
    personArray.toArray
  }
  
  def updatePerson(person: Me2Person): Unit = {
    val stmt = connection.prepareStatement("REPLACE INTO Me2Person VALUES (" +
                                             "?, ?, ?, ?, ?, " + 
                                             "?, ?, ?, ?, ?," +
                                             "?, ?, ?, ?, ?, ?)")
                              
    stmt.setString(1, person.id)
    stmt.setString(2, person.openid)
    stmt.setString(3, person.nickname)
    stmt.setString(4, person.face)
    stmt.setString(5, person.description)
    stmt.setString(6, person.homepage)
    stmt.setString(7, person.locationName)
    stmt.setString(8, person.locationTimeZone)
    stmt.setString(9, person.me2dayHome)
    stmt.setString(10, person.rssDaily)
    stmt.setString(11, person.invitedBy)
    stmt.setInt(12, person.friendsCount)
    stmt.setInt(13, person.totalPosts)
    stmt.setString(14, getOnlyDigits(person.updated))
    stmt.setString(15, getOnlyDigits(person.registered))
    stmt.setString(16, concatStringList(person.friendsList))
    
    //println(query)
    
    try {
      stmt.executeUpdate()
      connection.commit()
      //println("insertion success")
    } catch {
      case e => e.printStackTrace(); println("insertion fail")
    }
                              
  }
  
  def getDesc(userName: String): String = {
    val stmt = connection.prepareStatement("SELECT * FROM Me2Person WHERE id=?")
    stmt.setString(1, userName)
 
    val rs = stmt.executeQuery()
    var desc = ""
    rs.next() 
    desc = rs.getString("friendsList")
    
    desc
  }
  
  def getPerson(userName: String): Option[Me2Person] = {
    val stmt = connection.prepareStatement("SELECT * FROM Me2Person WHERE id= ? ")
    stmt.setString(1, userName)
    val rs = stmt.executeQuery()  
    val isFound = rs.next()
    if (isFound == false)
      return None
    else
    	return Some(new Me2Person(rs.getString(1), 
                                rs.getString(2), 
                                rs.getString(3), 
                                rs.getString(4), 
			                          rs.getString(5), 
			                          rs.getString(6), 
			                          rs.getString(7), 
			                          rs.getString(8), 
			                          rs.getString(9), 
			                          rs.getString(10), 
			                          rs.getString(11), 
			                          rs.getInt(12), 
			                          rs.getInt(13), 
                                rs.getString(14),
                                rs.getString(15),
			                          splitString(rs.getString(16))))

  }
  
  
  def updateFriendsList(userName: String, newFriendName: String): Unit = {
    val thisPerson = getPerson(userName)
    thisPerson match {
      case Some(person) => {
        if (person.friendsList.contains(newFriendName) == false) {
          val newList = newFriendName::person.friendsList
          person.friendsList = newList sort ((x, y) => x < y)
          //println("updated  Friend list here: " + person.friendsList)
          updatePerson(person)
        }
      }
      case None => {
        val newPerson = Me2Person.makePerson(userName)
        newPerson match {
          case Some(person) => updatePerson(person)
          case None => 
        }
      }
    }
  }
  
  
  def splitString(words: String): List[String] = {
    if (words == "") {
      return List[String]()
    } else {
      if (words.charAt(0) == ' ') {
        println("getperson error! friends list start with an whitespace")
        return (words.substring(1).split(" ").toList)
      } else {
        return words.split(" ").toList
      }
    }

  }
  
  def concatStringList(wordList: List[String]): String = {
    if (wordList.length == 0) {
      return ""
    }
    var builder = new StringBuilder();
    for (word <- wordList) {
      builder.append(word)
      builder.append(" ")
    }
    builder.deleteCharAt(builder.length - 1) // remove last ' '
    builder.toString
  }
  
  def getOnlyDigits(timestamp: String): String = {
    if (timestamp == null) {
      return null
    }
    println("calling getonlydigits on: " + timestamp)
    val charList = timestamp.toList
    return List.toString (charList filter (x => x >= '0' && x <= '9') )
  }
  
  def pushData() {
    val stmt = connection.prepareStatement("INSERT INTO TEST VALUES (?, ?)")
    val longString = "남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅남기웅"
    val shortString = "남기웅남기웅남기웅남기웅남기웅남기웅"
    val startTime: Double = System.currentTimeMillis() 
    val testSize = 500000
    val rowSize = 55
    for (i <- 1 to testSize) {
      stmt.setInt(1, i)
      stmt.setString(2, longString) 
      stmt.addBatch()
      if (i % 10000 == 0) {
        stmt.executeBatch() 
        connection.commit
      }
      if (i % 100000 == 0) {
      	println("Now done " + i + "'th row")
      }     
    }
    val endTime = System.currentTimeMillis()
    println("Throughput: " + testSize / (endTime - startTime) * 1000 * rowSize / 1000000 + "m/sec")
  }
}











